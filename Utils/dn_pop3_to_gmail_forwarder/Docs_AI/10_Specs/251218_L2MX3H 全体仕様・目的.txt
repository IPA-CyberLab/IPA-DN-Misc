このファイルは、このプロジェクトで作成するプログラムの全体仕様・目的を記述したものである。

1. このプログラムの目的
(1) このブログラムは、軽量なコマンドラインプロセスであり、実行する度に、以下の処理を実施することを目標としている。
(2) このプログラムは、ユーザーの自己の「POP3 メールボックス」に届いている新着メールを、ユーザーの自己の「Gmail メールボックス」にインポートすることを実現する。これにより、「POP3 メールボックス」のメールアドレス宛に届いたメールがあるとき、「Gmail メールボックス」にあたかも新着メールが届いたのと同様の取扱いで、「Gmail メールボックス」にメールが受信された挙動を実現する。
  1 個の「POP3 メールボックス」と 1 個の「Gmail メールボックス」をサポートするだけで足りる。
(3) (2) について、ユーザーは、常に電源が入っている任意の Linux マシン (Ubuntu 24.04 を想定) 上で、cron または supervisord 等の仕組みを用いて、本プログラムを 60 秒程度に 1 回呼び出すことにより、自動的・バックグラウンド的に (2) を定期実行することを予定している。
  ここで、本プログラムは、処理の結果、特に問題がなかった場合は、標準エラー出力に一切何も表示せず、プロセス戻り値は 0 を返さなければならない。他方で、処理の結果、たとえば、プロトコルエラーや認証エラー、Gmail の API が異常なエラーを返したような場合は、その旨の例外を標準エラー出力に記載するとともに、プロセス戻り値は 0 以外 (明示的に戻り値を指定する場合は「1」) を返さなければならない。ユーザーは、標準エラー出力の内容を、別途 syslog 等に記録し、これを確認することにより、エラーに気付くことができるのである。



2. このプログラムの動作モード
(1) このプログラムの、エントリポイント (Main 関数) は、「251218_K3VRU3 コマンドラインユーティリティ」パターンによって実装すること。

(2) プロセス起動時のコマンドライン引数による指定により、ユーザーは、以下の 2 つの動作モードのうち、いずれかを選択する。いずれのモードも指定されていない場合は、UNIX コマンドラインの伝統に合う懇切丁寧なコマンドライン引数ヘルプメッセージ (英語で記載すること) を出力し、エラーコード 1 で終了すること。

  (a) 「Gmail OAuth トークン取得モード」 (gettoken モード) [F3QBRBA9]
    - コマンドライン: 「gettoken --saveas <結果初期トークンJSONファイル> --client_id <Gmail API に対して予めユーザが登録しておいたクライアントアプリ ID> --client_secret <クライアントシークレット> --port <ポート番号>」
    - このモードは、ユーザーが、Windows または Linux 上の、自分のデスクトップ環境上で、コマンドラインから手動で呼び出して実行するモードである。ユーザーは、本プログラムの使用を開始する際に、1 回だけ、これを用いて、対象の「Gmail メールボックス」のアカウントに OAuth 接続して初期トークンを取得する。
    - このモードでは、ユーザーは、「デスクトップ / ネイティブアプリ向けの loopback (localhost 受け取り) 方式」で OAuth 初期トークンを取得できる。より具体的な手順は、次のとおりである。
      (i) ユーザーが gettoken を実行すると、プログラムは、一時的に、<ポート番号> で指定された 127.0.0.1 に TCP バインドされた HTTP サーバーを起動させる。この HTTP サーバーは、とても軽量な HTTP サーバーであり、Kestrel のような重厚なフレームワーク (外部ライブラリ) を必要とせず、SSL を必要としない生の HTTP サーバーを実装すること。HTTP サーバーが立ち上がったら、標準出力に、「http://127.0.0.1:<ポート番号>/start」・・・ [FSGX2FQ2] への接続を促すメッセージを出すこと。
      (ii) ユーザーが [FSGX2FQ2] にローカルマシンの Web ブラウザでアクセスすると、認証処理を開始する旨の簡単な案内の HTML が表示される。ここで「Start」のようなボタンがあり、ユーザーがこれをクリックすると、ハイパーリンクになっており、Google の「https://accounts.google.com/o/oauth2/auth」 (あるいは現在におけるより新しいURLがある場合はそのURL) に OAuth 接続手順により認証トークンを取得しにいくためのクエリ文字列を追加した形のURLにジャンプするようになっている。
      ここで、Scope は、「gmail.modify」とする。詳しくは Gmail API のベストプラクティスを参照すること。
      (iii) ユーザーが認証を終えると、「http://127.0.0.1:<ポート番号>/auth_callback」に処理が戻ってくる (ユーザーは予め <Gmail API に対して予めユーザが登録しておいたクライアントアプリ ID>、<クライアントシークレット>、「http://127.0.0.1:<ポート番号>/auth_callback」 を Google Deverlopers Console から Gmail のクライアントとして登録してあることを想定)。
      (iv) 認証結果を、<結果初期トークンJSONファイル> として書き出す。JSON 書式は [EG8R7RTE] とする。そのファイルに書き出した旨の案内メッセージを HTTP サーバーでユーザーに丁寧で面白みのある暖かい HTML で表示し、Web ブラウザを閉じて良い旨の記載とともに、Web ブラウザを閉じるためのボタンも用意する。
      (v) ユーザーは、このプロセスを、Ctrl + C などの普通の手段で強制終了する。

  (b) 「メール転送実施モード」 (forward モード) [AC579L84]
    - これについては、「3.」で詳述する。

  (c) 「設定検査モード」 (check モード) [251222_ZYMQ4U]
    - コマンドライン: 「check --config <設定ファイル>」 とする。
    - このモードは、(b) のモードと同様に config ファイルを読み込み、config ファイルの内容に形式的な不備がないかどうかチェックする。そのチェックルーチンは、[AC579L84] でのチェックルーチンと同一とする。実際に POP3 メールサーバーや Gmail メールサーバーとの間で一切通信することなく、config ファイルのみをチェックできる。
    - また、config ファイルのチェックにおいて、「filter_csharp_filename」が指定されている場合は、形式的に、このユーザーフィルタプログラムのコンパイルと 1 回限りの実行を試みる。すなわち、実際に「UserFilterClass.UserFilter」を呼び出してみて、例外が発生しないかどうか試してみる。ここで、「UserFilterClass.UserFilter」を呼び出す際に必要な MailForwardFilterParam パラメータにおける Mail メンバには、ダミーの MailMetaData を入れる。すべてのフィールドに、適当な乱数で生成したあり得ないようなサンプルのユーザー名やメールアドレス、本文などを入れた状態で「UserFilterClass.UserFilter」を呼び出してみること。

3. メール転送実施モードの仕様 [AC579L84]

(1) コマンドライン: 「forward --config <設定ファイル>」 とする。

(1-1) [251224_DDQDE9] この「メール転送モード」の実行について、万一、ユーザーが同一の「設定ファイル」に対して複数のプロセスを起動して同時に処理が行なわれると、競合が発生して不正な結果になる可能性がある。
  これを防ぐため、「メール転送モード」の開始時には、システム全体で有効なグローバル Mutex のようなものを用いて (この Mutex 的なものの ID は、config ファイルのフルパスとし、大文字・小文字を区別しないものとする)、多重起動を防止すること。多重起動している場合は、後に「メール転送モード」に突入しようとした側のプロセスは、例外を吐いてクラッシュさせること。例外メッセージの内容は、特定の config について forward モードが多重実行されようとしているため、という内容を英語で記載せよ。
  なお、システム全体における多重実行の禁止の方法は、Windows と Linux のいずれでも確実に動作する方法にせよ (必要に応じて Windows の場合と Linux の場合とで処理を分けてもよい)。

(2) 「設定ファイル」は、ユーザーがテキストエディタで記述した TOML ファイルであり、これを読み取り専用でロードする。設定ファイルは、[A44FBNFX] のような書式をしている。

--- [A44FBNFX] ここから ---

## 全体設定
[generic]

# [必須] アーカイブディリクトリ (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
archive_dir = "data/archive/"

# [任意] アーカイブディレクトリにメールを保存する際に、メール本体を圧縮するか
archive_enable_gzip = true

# [任意、ただし archive_enable_gzip が true の場合は必須] 一定日数が経過したら、アーカイブディレクトリの過日ディレクトリを tar アーカイブ化してファイル数を削減するか
archive_enable_tar = true

# [任意] archive_enable_tar = true の場合の、経過日数 (1 の場合: 昨日の年月日ディレクトリから tar 化する。2 の場合: 一昨日の年月日ディレクトリから tar 化する。3 の場合: 一昨日の前日の年月日ディレクトリから tar する。.... というルール)。archive_enable_tar = true の場合は、1 以上の整数でなければならない。
archive_enable_tar_pass_days = 1

# [必須] ログディレクトリ (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
log_dir = "data/log/"

# [必須] 統計ファイル名 (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
stat_filename = "data/stat.json"


## 転送フィルタ設定
[filter]

# [任意] 転送フィルタをユーザーが実装する C# ソースコードのファイル名 (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
filter_csharp_filename = "user_filter/filter.cs"


## メールの転送元 (POP3 受信側メールボックス) の認証設定
[pop3]

# [必須] POP3 サーバーホスト名または IP アドレス
hostname = "pop3.example.org"

# [必須] POP3 サーバーの TCP ポート番号
port = 995

# [必須] SSL 使用モード (none = 未使用, starttls = 使用し、かつ START TLS モード, full = 使用し、かつ TCP 接続時から SSL でラップ)
ssl_mode = "full"

# [必須] SSL を使用する場合でかつサーバー側証明書を検証するか
ssl_verify_server_cert = true

# [任意] SSL を仕様する場合でかつサーバー側証明書を検証する場合において、サーバーが提示した証明書の「SHA1 ハッシュ」、「SHA192 ハッシュ」、「SHA256 ハッシュ」、「SHA384 ハッシュ」、「SHA512 ハッシュ」のいずれかの値が、以下の設定項目に記載された ASCII で 16 進数 (大文字 / 小文字は区別しない、空白が入っていても無視) のうちいずれか (";" または "," 文字で区切ると複数個指定できて、いずれか 1 個と一致していれば良い) と一致していれば、そのサーバー証明書は信頼してよい (この場合、Common Name やサーバー FQDN との不一致も許容される。また、有効期限が切れた証明書であっても良い)。この設定値。
ssl_trusted_static_hash_list = "e3a9f4c27b1d8e6a90c5f12b7a4d3e8c9f0a6b2d;9f3c1a7e4b6d0c8a2e5f91b4d7a6c0e3f8b2d1a9c5e4f6b0d3a7e2c9"

# [必須] POP3 ユーザー認証のためのユーザー名
username = "aaa"

# [必須] POP3 ユーザー認証のためのパスワード
password = "bbb"

# [必須] TCP 接続リトライ回数
tcp_retry_attempts = 3

# [必須] TCP 接続タイムアウト秒数
tcp_connect_timeout_secs = 6

# [必須] TCP 通信の送信タイムアウト秒数
tcp_send_timeout_secs = 60

# [必須] TCP 通信の受信タイムアウト秒数
tcp_recv_timeout_secs = 60

# [必須] 1 回の POP3 ログインごとに回す最大メール数
max_batch_mails_per_login = 10


## メールの転送先 (Gmail API) の認証設定
[gmail]

# [必須] 「Gmail OAuth トークン取得モード」 (gettoken モード) [F3QBRBA9] で作成された Gmail 用トークンファイルを指定する。相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる。
token_json = "secret_token.json"

# [必須] Gmail API の HTTPS (SSL) においてサーバー側証明書を検証するか
ssl_verify_server_cert = true

# [必須] TCP 接続リトライ回数
tcp_retry_attempts = 3

# [必須] TCP 接続タイムアウト秒数
tcp_connect_timeout_secs = 6

# [必須] TCP 通信の送信タイムアウト秒数
tcp_send_timeout_secs = 60

# [必須] TCP 通信の受信タイムアウト秒数
tcp_recv_timeout_secs = 60

# [必須] トークンの更新間隔秒数
gmail_token_refresh_interval_secs = 15

# [必須] 最大メールバイト数
gmail_max_mail_size = 40000000

# [必須] システムメッセージの仮想メールアドレス
gmail_system_message_mail_address = "nobody <nobody@example.org>"


--- [A44FBNFX] ここまで ---

(3) メール転送実施モードが起動すると、まず、指定された TOML 設定ファイル [A44FBNFX] を読み込みパースする。スキーマと意味は [A44FBNFX] のコメント欄を参照すること。[必須] と記載されたフィールドは必須であり、空白またはおかしな値が入っていれば、例外を発生させる。

以下、致命的なエラーまたは警告的なエラーが発生したら、必ず、Error ログとして出力する。ログ内容メッセージは、英語とする。

(4) 次に、POP3 サーバーに接続し、ログインをする。なお、POP3 プロトコルは、.NET の BCL の TCP ライブラリおよび SSL ライブラリを用いて対話すること。POP3 プロトコルについて、外部の NuGet ライブラリを利用してはならない。POP3 プロトコルに係る TCP, SSL, タイムアウト等の制御パラメータは、[A44FBNFX] の各値を用いること。意味は、コメント欄を参照すること。

ログイン試行時およびログイン結果 (成功)、メールが何件あるか等の詳しい情報を、Info ログとして出力する。ログ内容メッセージは、英語とする。ただし、POP3 のユーザー名はログに記載するが、パスワードは、決して記載しない。

(4-1) ログインしたら、POP3 プロトコルを用いて、メールボックスに届いているメールを、1 件ずつ取得する。「(a) 1 件取得 → (b) アーカイブへの保存 → (c) Gmail への転送 → (d) その 1 件を削除」の順で繰り返す。ある (a) を開始したとき、(b) 、(c) を実施完了しない限り、絶対に、(d) は実施しないこと。これにより、仮に (b) または (c) への書き込みに失敗した場合にメールが失われるリスクを避けることができる。
 より詳細な手順は、次のとおりである。
 
 (a) 1 件取得
  POP3 プロトコルを用いて、メールを、1 件取得する。この時点では、メールはメールボックスから削除しない。
  ただし、すでに現在ログインしているセッションにおいて取得したメール数が max_batch_mails_per_login 件を超える場合は、いったん POP3 のレイヤでログアウトする。その後、再度、(4) に戻り、再度新たに POP3 にログインする。以降、POP3 の残りメールが全部なくなるまで、これを繰り返す。
  
  メールを取得したら、何件中何件目であるかと、取得したメールサイズを、Info ログとして出力する。ログ内容メッセージは、英語とする。
  
  [WZZM4P46] メール取得上の注意。POP3 プロトコルにおいては、最初のログイン後、(a)「STAT」によりメールの件数を取得し、次に、(b) LIST によりメールの一覧を取得する。(b) では、メール ID (そのセッション内でユニークな番号 [KHQN6UTY]) とメールサイズが列挙される。それ以降、RETR や DELE コマンドでは、[KHQN6UTY] を用いてメールを識別し、取得および削除する。この POP3 の手順を遵守すること。AI が最初に作成した「RunForwardInternalAsync」関数は、手抜きであり、「// ★ 1 セッション内では、常に 1 番目のメッセージを処理し続ける (削除したものは QUIT で反映され、再ログイン後も継続可能)」とあるが、これは 2 通以上のメールがメールボックスに入っているとはにうまくいかない。「[Error] APPERROR: POP3 error response: -ERR Message is deleted.」というエラーを発生させてしまう。十分注意し、POP3 プロトコルのコンベンションに併せるようにせよ。
 
 (a-2) メールを取得したら、メモリ内において、そのメールの内容をパースして ([Q9MZU6D5] 参照)、MailMetaData にメモリ上で格納する。電子メールのパースにおいて、一部パース困難な部分があっても、致命的例外を発生させずに、その困難な部分以外のパースをすること。ただし、完全にパースに失敗した場合は (そうなることはほとんど考えられないが)、MailMetaData の MailSize は単にメールサイズをバイト単位で格納し、PlainTextBody にはメールの本文をそのまま UTF-8 形式で無理矢理デコードした形式を入れること。

  パース結果の MailMetaData のうち、MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId の項目を、人間にわかりやすく、「POP3 サーバーから取得したメールの内容」として、Info ログとして出力する。

 (a-3) (a-2) で取得したメールに対して、メールフィルタ [251222_ZXH7N7] を実行し、ユーザー定義のフィルタ関数を呼び出す。そして、結果を MailForwardFilterResult 型として受け取る。
 
 (b) (a-2) で取得したメールを、アーカイブに保存する。アーカイブは、設定の「archive_dir」ディレクトリ内を作成し、さらに「YYYYMMDD」というサブディレクトリを作成し、その中に「YYYYMMDD_HHMMSS_SHA1_FROM64.txt」というファイル名で保存する (すでにそのファイルが存在する場合は、上書きをする)。[251224_BPAZU4]
   - 設定ファイル [A44FBNFX] の archive_enable_gzip が true の場合は、保存ファイルの拡張子は、.txt ではなく、代わりに、「.txt.gz」とする。そして、保存時においては、データを gzip 圧縮する。圧縮率が設定できる場合は、圧縮率は、最大とする。[251224_BEXKU2]
   - YYYYMMDD と HHMMSS は、MailMetaData の DateTime_Received を、プログラムを実行しているコンピュータのローカル時刻にした日時 (日付 8 桁、時刻 6 桁) である。DateTime_Received が不明の場合は、「(a) で取得をした時点の日付 + 午前 00:00:00 の時刻」とすること。DateTime_Header は信頼できないので、参照しない。[CQVFZY4W] [251224_BPAZU4]
   - SHA1 の部分は、「MailMetaData」を変数として、JSON に変換した結果を UTF-8 エンコードし、これを SHA1 でハッシュ化したものを、小文字 16 進数表記した値とする。たとえば、「2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c」のような値である。メールによって異なるが、複数回同じメールを POP3 サーバーから取得しても、同じ値になるはずである。
   - FROM64 の部分は、MailMetaData の AddressList_From におけるメールアドレス部分 (aaa@example.org のような部分) をそのまま記載する。ただし、「a-z」「A-Z」「0-9」「@」「+」「-」「_」「.」以外の文字は、すべて、安全のため、「_」に置換すること。また、文字数が 64 文字を超える場合は、先頭 64 文字のみにすること。
   - txt ファイルの内容は、次のようなバイナリファイルとすること。
     -- 先頭に、UTF-8 の BOM を付ける。
     -- ファイルの先頭部分には、まず、2 行改行を開けてから、「-- BEGIN MailMetaData --」と記載し、1行改行をして、MailMetaData をそのままシリアライズ化した結果の JSON データがバイナリとして貼り付けられる (その内部表現形式は JSON であるので UTF-8 である)。最後に、「-- END MailMetaData --」と記載し、1 行改行をする。
     -- 次に、2 行改行を開けてから、「-- BEGIN MailForwardFilterResult --」と記載し、1行改行をして、MailForwardFilterResult をそのままシリアライズ化した結果の JSON データがバイナリとして貼り付けられる (その内部表現形式は JSON であるので UTF-8 である)。最後に、「-- END MailForwardFilterResult --」と記載し、1 行改行をする。[251222_ZXH7N7]
     -- 次に、JSON データの次に 2 行改行を開けて、「===================================================================」 [U2LFKTKR] という文字列を貼り付け、改行する。
     -- 最後に、元の (a) で取得したこのメールの内容バイナリを、一切変更せず、そのまま書き出す。
   - つまり、1 個の txt ファイルに、メールを MailMetaData にパースした結果 (メタデータ的なもの) と、メールのデコード前のデータ (生データ) とが、[U2LFKTKR] という区切り文字列を境界として、共存している状態の内容とする。
   
  Info ログとして、アーカイブ保存した txt ファイルの出力先ファイル名とファイルサイズをわかりやすく出力する。

 (c) Gmail への転送処理は、次のように行なわれる。ただし、メールサイズが "gmail_max_mail_size" を超えている場合は、その旨を詳しく Error ログに記載して (書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId を、わかりやすく、併記する) 、Gmail への転送をスキップする。
 
   [A] Gmail に HTTPS API で接続する際の、HTTPS プロトコルに係る TCP, SSL, タイムアウト等の制御パラメータは、[A44FBNFX] の各値を用いること。意味は、コメント欄を参照すること。
    Gmail との通信は、.NET の BCL の TCP ライブラリおよび SSL ライブラリを用いて対話すること。Gmail API プロトコルについて、外部の NuGet ライブラリを利用してはならない。
   
   [B] Gmail API を呼び出すためのクレデンシャルは、[F3QBRBA9] で作成された、[A44FBNFX] 内の 「token_json」に指定されている JSON ファイルを使用すること。この JSON ファイルをまず読み取りで読む。LastRefreshDt よりも gmail_token_refresh_interval_secs 秒以上経過していたら、トークンの更新処理行なう。トークンの更新処理で新しいトークンが得られたら、「token_json」に指定されている JSON ファイルにそのトークンを書き込むこと。
   
   [C] Gmail API では、「users.messages.import」 API を用いて、この 1 件のメールのデータ ((a) で取得したものそのまま) を、ユーザーの Gmail 受信トレイに書き込む。[T3C34TDJ] [251222_ZXH7N7]
      - ここで、まず、「INBOX」というラベルを確実に付ける。これは、Gmail の「受信トレイ」にインポートすることを明示的に意味する。
      - 次に、MailForwardFilterResult の MarkAsRead が false の場合は、「UNREAD」というラベルを確実に付ける (Gmail 上での既読を意味)。つまり、フィルタ結果として MarkAsRead が true の場合は、「UNREAD」というラベルを確実に付けない (Gmail 上での既読を意味)。
      - そして、MailForwardFilterResult の LabelList に記載されている名前のラベル (これは、Gmail のユーザー定義ラベル名を意味する) がある場合 (複数指定されている場合もある) は、それらのラベルを必ず付ける。
      - インポート時は、neverMarkSpam=True オプションを有効にすること。[N9YQARM8]

  Info ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、これが Gmail メールボックスに書き込み完了した旨を、わかりやすく、出力する。
   
   [D] [C] の書き込みがエラーなく完了したことをもって、(d) へ行く。なお、何らかのエラーが発生した場合は、例外を発生させ、この時点でプログラムを終了させる。
   ただし、Gmail に 1 件のメールをアップロードしようとして、「400 Bad Request」が応答された場合、必要に応じた添付ファイルの削除処理 [GTFE562C] を行ない、それでもなおエラーになる場合のみ、例外を発生させ、この時点でプログラムを終了させる。[ULP8TK5N]

 (d) 最後に、POP3 サーバーから、対象メールを削除する処理を行なう。
  Info ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、これを POP3 サーバーから削除した旨を、わかりやすく、出力する。
 
 (e) (d) まで無事終わったら、以下の処理を実施する。[251224_CKS4SV]
   (e-1) まず、統計情報記録機能 [251224_CJU4PT] を実行し、統計データを更新する。
   (e-2) 次に、ここに到達したのが、本日 (ローカルタイムゾーンの時刻上の本日) 初めての場合 (「本日初めて」とは、(e-1) で実施した統計情報記録において、処理前の JSON ファイルに記録されていた LastRunOkDt の値における日付 (ローカルタイムゾーンに基づいて比較) が本日よりも前の過去日である場合とする。) は、archive_enable_tar = true の場合に限り、自動 tar アーカイブ機能 [251224_CCNR2A] を実行する。つまり、自動 tar アーカイブ機能は、1 日に 1 回しか呼ばれない、ということになる。

4. 自動 tar アーカイブ機能 [251224_CCNR2A]
この機能は、設定ファイル [A44FBNFX] で、archive_enable_tar が true の場合のみ利用される。この機能は、本仕様書において明示的に記載されている条件に一致した場合のみ、実施される。

(1) アーカイブディレクトリには、メールのアーカイブが、[251224_BPAZU4] で示された方式により、次々にファイルとして保存されていく。これらは、メールごとに 1 個のファイルが保存されるので、そのままだと、次第に、ディスクには大量のファイルが蓄積されていくことになる。メールは数百万件になることがあるので、Linux や Windows のファイルシステムにファイルが極めて膨大に増えていき、ファイルシステムが、だんだん不安定になるリスクがある。

(2) そこで、(1) のリスクを避けるため、自動 tar アーカイブ機能を用意し、多数のメールアーカイブを、日付ごとに 1 つの .tar ファイルに結合し、ファイルシステム上のファイル数を減らす。この機能は、アーカイブディレクトリの、各日付のディレクトリ 1 個 (この章において、「対象ディレクトリ」という。) ごとに、次の処理をするものである。その 1 個の「対象ディレクトリ」の処理中に何か致命的なエラーが生じた場合は、「Error ログ」として、その詳細 (何が起こったか、どのディレクトリか、どのファイルの処理中か、どのような処理に失敗したのか、どのような例外が発生したのか) を記録すること。
  - アーカイブディレクトリには、複数の「YYYYMMDD」というような 8 桁の年月日のディレクトリ名のサブディレクトリが存在している。これは [251224_BPAZU4] の原理によって 1 日に 1 ディレクトリが作成されているのである。
   -- ここで、設定ファイル [A44FBNFX] の archive_enable_tar_pass_days 項目のコメント欄に記載があるとおり、現在の日付 (ローカル時計における DateTime.Now.Date を取得してこれと比較すればよい) までの経過日数に基づいて、可能性のある「対象ディレクトリ」のそれぞれの「YYYYMMDD」の日付がすでに指定された分だけ経過しているディレクトリに限り (archive_enable_tar_pass_days が 0 の場合はすべての場合にこの条件はパスする。すなわち本日のディレクトリも含む)、その「対象ディレクトリ」を、「処理予定の対象ディレクトリ」としてリストアップする。ただし、ディレクトリ名が「YYYYMMDD」の形式であり、かつ、日付としてパース可能で、さらには未来日でないことが条件である。「YYYYMMDD」という形式に合わないディレクトリは、すべて無視せよ。
  - 「処理予定の対象ディレクトリ」は、内部的に、日付順でソートし、小さいほうから逐次処理をする。
  - 「処理予定の対象ディレクトリ」中における、ある 1 個の「対象ディレクトリ」(「YYYYMMDD」というような 8 桁の年月日のディレクトリ名) 内にある、すべての .txt および .txt.gz ファイル群が 1 個以上あれば、これらのファイル群を、ファイル名順にソートした上で、1 つの tar ファイルに結合する (この際、圧縮処理は行なわない。単に結合して .tar を作成するだけである) [251224_BYD2W6]。これらのファイル群が 1 つもない場合は、その「処理予定の対象ディレクトリ」については、何もしなくてよい。
    -- tar ファイルに入れる、.txt または .txt.gz ファイルの tar 内における表現形式として、「ファイル名」は、その .txt または .txt.gz ファイルのファイル名をそのまま利用する。ディレクトリ名は入れない。mode は "0000777" とする。更新日時は、元のファイルの更新日時とする。type フラグは 0 とする。GIDとUIDは、"0000000" とする。
  - .tar ファイルのファイル名は、「YYYYMMDD.tar」(YYYMMDD は 8 桁の年月日) とする。つまり、対象の 1 個の「対象ディレクトリ」の YYYYMMDD をそのまま .tar のファイル名とする。結果として、「20251224/20251224.tar」というファイル名になるであろう。
  - この処理を実施する際に、すでに、「YYYYMMDD.tar」ファイルが存在する場合がある。
   -- この場合は、[251224_BYD2W6] で言及されている対象各ファイルは、すでに存在する「YYYYMMDD.tar」ファイルの内容に追記する。
   -- すでに存在する .tar への追記は、少し複雑な処理であるから、慎重に実装する必要がある。
   -- なお、これによって出来上がった .tar ファイル内の各ファイルの並び順は、すでに .tar に存在するファイル群の並びの末尾に、新たに追記されるファイルが入るので、[251224_BYD2W6] で述べた「ファイル名順にソート」とならない場合があるが、それは許容する (新たに追記されるファイル群が複数の場合は、これらのファイル間では、「ファイル名順にソート」を遵守せよ)。
   -- ある .txt または .txt.gz ファイルを .tar に追記しようとする際において、すでに .tar ファイル内に同一のファイル名のファイルが存在している場合には、追記をしないこと。これは本来は発生しない異常な状態であるから、「Error ログ」として、その詳細 (何が起こったか、どのディレクトリか、どのファイルの処理中か、どのような処理に失敗したのか、どのような例外が発生したのか) を記録すること。
  - .tar ファイルへの書き込み (追記も含む) に成功した場合に限り、その対象となった .txt または .txt.gz ファイルを削除する。.tar ファイルへの書き込み (追記) に失敗した場合は、元の .txt または .txt.gz を削除すると、情報が失われるので、追記してはならない。


81. ログ記録機能 [251224_CJR3EX]
(1) このプログラムの仕様で、「Error ログ」または「Info ログ」を出力するよう指示があった場合は、次のとおりログ出力をしなければならない。

(2) ログは、1 ログ 1 行のデータであり、[Y5CRNZA3] の書式を有する。
--- [Y5CRNZA3] ここから ---
YYYY/MM/DD HH:MM:SS.SSS +XX:XX [Type] 本文
--- [Y5CRNZA3] ここまで ---

「YYYY/MM/DD HH:MM:SS.SSS +XX:XX」は、ログを出力しようとする瞬間の日時 (ミリ秒単位) である。タイムゾーンを併記し、タイムゾーンはシステムのローカル時計設定にあわせる。

Type には、Error または Info のいずれかが入る。

本文は、1 行の何らかの 0 文字以上の文字列である。ログ書き込みをしようとする側が、改行を含んでいた場合は、改行 ("\r\n" または "\n") は、" / " という文字に置換され、必ず 1 行となる。

(3) ログは、設定ファイル [A44FBNFX] の「log_dir」ディレクトリ内に、「YYYYMMDD.log」というファイル名で保存 (追記型書き込み) される。[251224_BPAZU4]

(4) ログを保存しようとする際には、それと全く同一の行を、Error の場合は標準エラー出力、Info の場合は標準出力に文字列として出力する。

(5) ログの保存またはディレクトリの作成に失敗した場合の例外は、その旨を標準エラー出力に出した上で、続行する (例外を無視する)。


82. 統計情報記録機能 [251224_CJU4PT]
(1) 設定ファイル [A44FBNFX] の「stat_filename」で指定された JSON ファイル (まだない場合は、作成すること) に、以下の [251224_CKJBE4] のような内容を記録する。この JSON ファイルの指定されたパスのためのディレクトリがない場合は、ディケクトリも作成すること。

(2) その際、統計情報のうち大半は累積値であるから、すでに存在する JSON ファイルのパース (読み取り) をした上で、今回分の増分・差分を書き込んで、JSON ファイルに書き出す必要がある。すでに存在する JSON ファイルのパース (読み取り) に失敗した場合は、「Error ログ」にその旨を書き出した上で、新規の new LibMailFwdStatInfo() を作成し、これにデータを記載した上で、JSON ファイルとして書き出す。

(3) JSON ファイルは、BOM あり UTF-8 ファイルとする。

(4) JSON ファイルに統計を書くときには、その書くべき JSON 内容について、別途 JSON シリアライズ (ただし、改行を含まない JSON データとしてコンパクト化し 1 行にしたもの) を、「Info ログ」として書き出すこと。これにより、万一統計 JSON データファイルが消失・破損しても、Info ログから、ユーザーが手動で JSON 統計を復旧することができるためである。

(5) 万一 JSON ファイルへの書き込みが失敗した場合は、「Error ログ」にその旨を書き出した上で、続行する (例外でクラッシュさせない、という意味)。

--- [251224_CKJBE4] ここから ---
public class LibMailFwdStatInfo
{
    public DateTimeOffset LastRunOkDt; // 最後に転送処理が成功した日時 (要するに最後に [251224_CKS4SV] に到達した日時) (ローカルタイムゾーン形式で表示せよ)
    public long NumMails; // これまで転送処理 (転送に成功) したメール数
    public long NumErrors; // これまで発生したエラー数
    public long TotalMailSize; // これまで転送処理 (転送に成功) したメールのメールサイズの合計バイト数
}
--- [251224_CKJBE4] ここまで ---


91. Gmail との OAuth トークン情報 JSON ファイルの書式 [EG8R7RTE]
--- ここから ---
public class GMailOAuthTokenJsonData
{
    public DateTimeOffset LastRefreshDt; // 最後に更新された日時
    public string AppClientId; // クライアントアプリ ID
    public string AppClientSecret; // クライアントシークレット
    public string UserAccessToken; // アクセストークン (必要に応じて更新される)
}
--- ここまで ---


92. メール本文の内部データ [VZR2Y5BY]
--- ここから ---
public class MailMetaData
{
    public int MailSize;   // メールのサイズ (単位: バイト)
    
    public string Subject; // Subject の文字列。デコード済み。無い場合は ""。
    
    public DateTimeOffset? DateTime_Header; // Date ヘッダの日時。不明な場合は null。注意: [YU4CRZ2B] を参照。
    
    public DateTimeOffset? DateTime_Received; // Received ヘッダから推定されるメールの配信日時。不明な場合は null。注意: [KDXFFA9U] を参照。
    
    public string MessageId; // メッセージ ID 文字列。無い場合は ""。
    
    public System.Net.Mail.MailAddress? AddressList_From; // From メールアドレス。不明な場合は null。
    public List<System.Net.Mail.MailAddress> AddressList_To; // To メールアドレス一覧。存在しない場合は空のリスト。
    public List<System.Net.Mail.MailAddress> AddressList_Cc; // Cc メールアドレス一覧。存在しない場合は空のリスト。
    public List<System.Net.Mail.MailAddress> AddressList_ReplyTo; // ReplyTo メールアドレス一覧。存在しない場合は空のリスト。
    public List<string> AddressList_ReturnPath; // Return-Path アドレス一覧。存在しない場合は空のリスト。注意: "<username@example.org>" あるいは "aaa bbb <username@example.org>" の形式で元メールに入っている場合、メールアドレス部分、すなわち "<>" を除外した "username@example.org" の部分のみを格納せよ。なお、"<>" となっている場合は、その部分は、空文字 "" を格納せよ。なお、"username@example.org" の部分のみ元メールに入っている場合は、それをそのまま利用せよ。 [SS9R4XHX]
    public List<string> AddressList_OriginalTo; // X-Original-To アドレス一覧。存在しない場合は空のリスト。[SS9R4XHX] の注意書きに同じ。
    public List<string> AddressList_DeliveredTo; // Delivered-To アドレス一覧。存在しない場合は空のリスト。[SS9R4XHX] の注意書きに同じ。
    
    public string PlainTextBody; // 平文メールとして処理したときの平文メール本文全文 (デコード済み)。平文部分が存在しない場合は ""。
    public string HtmlBody; // HTML メールとして処理したときの HTML メール本文全文 (デコード済み)。HTML メールではない場合は ""。
    public string HtmlBodyToPlainText; // HtmlBody には、HTML タグが詰まっていて、「&nbsp;」や HTML のいろいろなエンコード方式でのエスケープがなされている可能性がある。これを、あとで全文検索エンジンに投入可能な程度に、普通の平文文字列に置換した状態 (つまり、ユーザーがテキストビューアでそのメールを表示しようとすると表示されるべき状態) の文字列を格納する。HTML メールではない場合は ""。
    
    public List<string> AttachmentFileNamesList; // 添付ファイル名のリスト。存在しない場合は空のリスト。なお、HTML メールの場合、HTML 本文や HTML 本文内の画像などが含まれている場合があるが、これらは添付ファイルとしてはここに入れないこと。普通のメーラにおいて、「添付ファイル」であるとみなされるものが、添付ファイルである。
}
--- ここまで ---

92-2. Received ヘッダから日時を取得する際の注意 [KDXFFA9U]
(1) メールの Received ヘッダの表記方法には、歴史的経緯から、色々な揺れがある可能性がある。その揺れについて詳しくリサーチし、それを解消して、確実に日時が取得できる方法によるパーサーを作成すること。
(2) 一例として、[C993C7RT] のようなメールがみられる。[C993C7RT] のようなものは、確実にパースできるようにすること。他にも色々トラブル原因あると思うので、インターネットで色々な方言について調査研究し、良いパーサーを書くこと。

--- [C993C7RT] ここから ---
Received: from mail-qv1-f48.google.com (mail-qv1-f48.google.com [209.85.219.48])
	by example.org (Postfix) with ESMTPS id 5D64D1292BDF
	for <example.org@example.org>; Thu, 18 Dec 2025 20:45:02 +0900 (JST)
Received: by mail-qv1-f48.google.com with SMTP id aaaa-bbbba.0
        for <example.org@example.org>; Thu, 18 Dec 2025 03:45:02 -0800 (PST)
--- [C993C7RT] ここまで ---


92-3. Date ヘッダから日時を取得する際の注意 [YU4CRZ2B]
(1) メールの Date ヘッダの表記方法には、歴史的経緯から、色々な揺れがある可能性がある。その揺れについて詳しくリサーチし、それを解消して、確実に日時が取得できる方法によるパーサーを作成すること。
(2) (1) のパーサーについて、「MimeKit」のライブラリにその揺れの吸収が可能な機能があり、かつ、それが信頼できる場合は、それを利用すること。


93. Gmail メールをアップロードしようとして、「400 Bad Request」が応答された場合の、必要に応じた添付ファイルの削除処理 [GTFE562C]
(1) Gmail にウイルス等の疑いがあるメール (添付ファイル付きメール、本文にマルウェアの URL が記載されているメール等) をアップロードしようとすると、「400 Bad Request」というエラーが Gmail API から応答されることがある。
(2) この場合、以下の (a), (b), (c) のメールを内部的にメモリ上で作成し、順に、インポートを再試行する。(a), (b), (c) の順で、1 つでもインポートが成功すれば、残りは不要である。
   (a) メールから、[LA5UBK7L] の拡張子を有するファイル名 (あるいはこれらのファイル名に .gz または .bz2 が付いたファイル名) のすべての添付ファイルを削除したもの。この処理は MimeKit で可能である。
   (b) メールに .zip, .tar.gz, .tgz, .tar のアーカイブファイルが付いている場合は、その内容を走査して (ファイルの内容そのものは読まず、ファイル名だけ読めば良い)、それらの中に、[LA5UBK7L] の拡張子を有するファイル名 (あるいはこれらのファイル名に .gz または .bz2 が付いたファイル名) がある場合は、その添付ファイルたるアーカイブファイルを削除したもの。この処理は MimeKit で可能である。
   (c) メールからすべての添付ファイルを削除したもの。この処理は MimeKit で可能である。
   なお、(a), (b), (c) において、メールの「Subject」文字列には、「【注: 転送時に添付ファイル削除】 ○○」という文字列を前置すること (○○ は元の Subject 文字列)。元の Subject 文字列がない場合、「○○」の部分は空文字にすること。
(3) (2) で、すべてのインポートで、「400 Bad Request」が応答された場合は、代わりに「システムメッセージ」 ([HA7DHHGE]) を作成し、これをメールボックスにインポートする。システムメッセージの [件名] は、[L58QWMGX] とし、 <> の部分は指示に従って埋める。本文は、[G35AJFPZ] とし、<> の部分は指示に従って埋める。
(4) システムメッセージのインポートに成功した場合、Error ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、"Gmail サーバーへのインポートに失敗した" 旨を、わかりやすく、出力する。
(5) (2) または (3) でインポートに成功したら、そのメールの Gmail へのインポートは成功したとみなす。それ以外の場合は、エラーとみなす。

--- [LA5UBK7L] ここから ---
.ade, .adp, .apk, .appx, .appxbundle, .bat, .cab, .chm, .cmd, .com, .cpl, .diagcab, .diagcfg, .diagpkg, .dll, .dmg, .ex, .ex_, .exe, .hta, .img, .ins, .iso, .isp, .jar, .jnlp, .js, .jse, .lib, .lnk, .mde, .mjs, .msc, .msi, .msix, .msixbundle, .msp, .mst, .nsh, .pif, .ps1, .scr, .sct, .shb, .sys, .vb, .vbe, .vbs, .vhd, .vxd, .wsc, .wsf, .wsh, .xll,
--- [LA5UBK7L] ここまで ---

--- [L58QWMGX] ここから ---
【メール転送インポート失敗】: Subject: <○○○> (From: <AddressList_From>)
--- [L58QWMGX] ここまで ---

--- [G35AJFPZ] ここから ---
以下のメールを Gmail API を用いて転送インポートしようとしたところ、
エラーメッセージ「ERROR」が発生しました。

メールのサイズ: <XXX> バイト
メールの Subject: <○○○>
メールの日時: <DateTime_Header を文字列化したもの>
メールの From: <AddressList_From を文字列化したもの>
メールの To: <AddressList_To (複数あるときは ", " で結合) を文字列化したもの>
メールの Cc: <AddressList_Cc (複数あるときは ", " で結合) を文字列化したもの>
メールの添付ファイルの数: <○> 個
--- [G35AJFPZ] ここまで ---


93-2. Gmail へのシステムメッセージのアップロード [HA7DHHGE]
(1) システムメッセージのメールは、次のとおりとする。
- From, To はいずれも [A44FBNFX] の gmail_system_message_mail_address の文字列とする。
- ReturnPath は gmail_system_message_mail_address の文字列のうちメールアドレス部分 ( "<username@example.org>" あるいは "aaa bbb <username@example.org>" の形式で元メールに入っている場合、メールアドレス部分、すなわち "<>" を除外した "username@example.org" の部分のみを格納せよ。) とする。
- MessageId は RFC に準拠し乱数で絶対重複しない ID 文字列を生成して格納すること。
- Subject は「sysmsg [件名]」とする。
- Body はテキスト文字列とする。
- エンコーディングは UTF-8 とする。
- Date は、そのメッセージを作成した日時とする。
(2) (1) で作成したシステムメッセージは、[T3C34TDJ] と同等の方法でインポートすること。これにより、ユーザーは、メールボックスを通じて、そのメールを確認できる。
(3) (2) のインポート時に、万一システムメッセージのインポートでエラーが発生したら、その旨は Error ログとして記録するが、例外はキャッチし、無視して続行する。



94. メールフィルタ [251222_ZXH7N7]
(1) 本アプリケーションのメール転送機能においては、入力メール (POP3 から入ってくるメール) 1 件ずつに対して、フィルタ関数を通し、これにより、出力 (Gmail へのインポート) 時の挙動を変化させることができる。
(2) (1) のフィルタ関数は、本ソフトウェアのユーザーが、本ソフトウェア本体のソースコードをリビルドすることなく、本ソフトウェアの「外部モジュール」としてユーザー定義スクリプトを C# で実装することができるというものである。
(3) (2) の仕組みは、すでに実装済みの「lib_mailfilter.cs」の「LibMailFilterExec.CompileAndInvokeUserFilter」メソッドによって実現可能である。この「LibMailFilterExec.CompileAndInvokeUserFilter」メソッドは、入力引数として、「string sourceCode, MailForwardFilterParam param」をとる。sourceCode には、ユーザーが記述したユーザー定義関数が含まれた c# のソースコードの本文文字列を入れる。param には、フィルタにかけるメールを入れる。param.Mail はメール本体 (MailMetaData) である。
(4) sourceCode に入れるべきユーザー定義コードは、設定ファイルの「[filter]」の「filter_csharp_filename」としてファイル名が指定されている。このファイルを普通のファイルとして読み込んで、「LibMailFilterExec.CompileAndInvokeUserFilter」にかければよい。(「[filter]」の「filter_csharp_filename」としてファイル名が指定されていない場合は、ユーザー定義フィルタは存在しないことを意味する。この場合は、 MailForwardFilterResult を単に new() しただけのデフォルトフィルタ結果を用いて処理すること。すなわち、特別な処理はしない、ということになる。 [251223_ADBP7R])
(5) ユーザーは、以下の [251223_ABQ2UB] のようなフィルタプログラムをC#で記述し、「[filter]」の「filter_csharp_filename」として指定したファイル名で設置することになる。
  ここで、「MailForwardFilterParam」と「MailForwardFilterResult」の内容・意味は、すでに定義済みの MailForwardFilterParam と MailForwardFilterResult の 2 つのクラスのコメントおよび定義を参照すること。

--- [251223_ABQ2UB] ここから ---
public static class UserFilterClass
{
    public static MailForwardFilterResult UserFilter(MailForwardFilterParam mail)
    {
        MailForwardFilterResult result = new();

        // ここで mail の内容を検査して何らかのフィルタ処理を実施

        result.MarkAsRead = true;

        result.LabelList.Add(""Label1"");
        result.LabelList.Add(""Label2"");

        return result;
    }
}
--- [251223_ABQ2UB] ここまで ---

(6) フィルタの実行中に (要するに 「LibMailFilterExec.CompileAndInvokeUserFilter」 の呼出し時に)、何らかの例外が発生する可能性がある。原因は、ユーザーコードのコンパイルエラーのほか、実行時エラー等である。そのような例外が発生した場合は、Error ログとして、その例外の内容とともに、その旨を詳しく Error ログに記載して (書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId を、わかりやすく、併記する)、かつ、[251223_ADBP7R] と同一の処理をする (つまり、特になにもせずメールは転送される)。要するにフィルタを実行しようとしていかなる問題が発生しても、必ず、処理は続行されなければならない。

(7) フィルタの結果は、1 メール毎に、MailForwardFilterResult として結論される。この MailForwardFilterResult の結果に基づき、Gmail へのインポート時の挙動を調整する。詳しくは、[T3C34TDJ] を参照すること。

99. 使用ライブラリ (Nuget) [Q9MZU6D5]
- TOML 設定ファイルの読み書きが必要な場合には、「Tomlyn」ライブラリを使用すること。
- POP3 等において、電子メールデータのパースには、「MimeKit」ライブラリを使用すること。
- TAR の読み書き処理については、BCL 以外の TAR 用のライブラリは使用しないこと。必要があれば、本プログラム内で、自前でライブラリを実装すること (その場合、lib_tar.cs というファイル名にせよ)。TARライブラリは、十分の柔軟性がある実装とすること。




