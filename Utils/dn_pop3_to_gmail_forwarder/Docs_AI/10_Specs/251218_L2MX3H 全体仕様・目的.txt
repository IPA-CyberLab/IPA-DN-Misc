このファイルは、このプロジェクトで作成するプログラムの全体仕様・目的を記述したものである。

1. このプログラムの目的
(1) このブログラムは、軽量なコマンドラインプロセスであり、実行する度に、以下の処理を実施することを目標としている。
(2) このプログラムは、ユーザーの自己の「POP3 メールボックス」に届いている新着メールを、ユーザーの自己の「Gmail メールボックス」にインポートすることを実現する。これにより、「POP3 メールボックス」のメールアドレス宛に届いたメールがあるとき、「Gmail メールボックス」にあたかも新着メールが届いたのと同様の取扱いで、「Gmail メールボックス」にメールが受信された挙動を実現する。
  1 個の「POP3 メールボックス」と 1 個の「Gmail メールボックス」をサポートするだけで足りる。
(3) (2) について、ユーザーは、常に電源が入っている任意の Linux マシン (Ubuntu 24.04 を想定) 上で、cron または supervisord 等の仕組みを用いて、本プログラムを 60 秒程度に 1 回呼び出すことにより、自動的・バックグラウンド的に (2) を定期実行することを予定している。
  ここで、本プログラムは、処理の結果、特に問題がなかった場合は、標準エラー出力に一切何も表示せず、プロセス戻り値は 0 を返さなければならない。他方で、処理の結果、たとえば、プロトコルエラーや認証エラー、Gmail の API が異常なエラーを返したような場合は、その旨の例外を標準エラー出力に記載するとともに、プロセス戻り値は 0 以外 (明示的に戻り値を指定する場合は「1」) を返さなければならない。ユーザーは、標準エラー出力の内容を、別途 syslog 等に記録し、これを確認することにより、エラーに気付くことができるのである。



2. このプログラムの動作モード
(1) このプログラムの、エントリポイント (Main 関数) は、「251218_K3VRU3 コマンドラインユーティリティ」パターンによって実装すること。

(2) プロセス起動時のコマンドライン引数による指定により、ユーザーは、以下の 2 つの動作モードのうち、いずれかを選択する。いずれのモードも指定されていない場合は、UNIX コマンドラインの伝統に合う懇切丁寧なコマンドライン引数ヘルプメッセージ (英語で記載すること) を出力し、エラーコード 1 で終了すること。

  (a) 「Gmail OAuth トークン取得モード」 (gettoken モード) [F3QBRBA9]
    - コマンドライン: 「gettoken --saveas <結果初期トークンJSONファイル> --client_id <Gmail API に対して予めユーザが登録しておいたクライアントアプリ ID> --client_secret <クライアントシークレット> --port <ポート番号>」
    - このモードは、ユーザーが、Windows または Linux 上の、自分のデスクトップ環境上で、コマンドラインから手動で呼び出して実行するモードである。ユーザーは、本プログラムの使用を開始する際に、1 回だけ、これを用いて、対象の「Gmail メールボックス」のアカウントに OAuth 接続して初期トークンを取得する。
    - このモードでは、ユーザーは、「デスクトップ / ネイティブアプリ向けの loopback (localhost 受け取り) 方式」で OAuth 初期トークンを取得できる。より具体的な手順は、次のとおりである。
      (i) ユーザーが gettoken を実行すると、プログラムは、一時的に、<ポート番号> で指定された 127.0.0.1 に TCP バインドされた HTTP サーバーを起動させる。この HTTP サーバーは、とても軽量な HTTP サーバーであり、Kestrel のような重厚なフレームワーク (外部ライブラリ) を必要とせず、SSL を必要としない生の HTTP サーバーを実装すること。HTTP サーバーが立ち上がったら、標準出力に、「http://127.0.0.1:<ポート番号>/start」・・・ [FSGX2FQ2] への接続を促すメッセージを出すこと。
      (ii) ユーザーが [FSGX2FQ2] にローカルマシンの Web ブラウザでアクセスすると、認証処理を開始する旨の簡単な案内の HTML が表示される。ここで「Start」のようなボタンがあり、ユーザーがこれをクリックすると、ハイパーリンクになっており、Google の「https://accounts.google.com/o/oauth2/auth」 (あるいは現在におけるより新しいURLがある場合はそのURL) に OAuth 接続手順により認証トークンを取得しにいくためのクエリ文字列を追加した形のURLにジャンプするようになっている。
      ここで、Scope は、「gmail.modify」とする。詳しくは Gmail API のベストプラクティスを参照すること。
      (iii) ユーザーが認証を終えると、「http://127.0.0.1:<ポート番号>/auth_callback」に処理が戻ってくる (ユーザーは予め <Gmail API に対して予めユーザが登録しておいたクライアントアプリ ID>、<クライアントシークレット>、「http://127.0.0.1:<ポート番号>/auth_callback」 を Google Deverlopers Console から Gmail のクライアントとして登録してあることを想定)。
      (iv) 認証結果を、<結果初期トークンJSONファイル> として書き出す。JSON 書式は [EG8R7RTE] とする。そのファイルに書き出した旨の案内メッセージを HTTP サーバーでユーザーに丁寧で面白みのある暖かい HTML で表示し、Web ブラウザを閉じて良い旨の記載とともに、Web ブラウザを閉じるためのボタンも用意する。
      (v) ユーザーは、このプロセスを、Ctrl + C などの普通の手段で強制終了する。

  (b) 「メール転送実施モード」 (forward モード) [AC579L84]
    - これについては、「3.」で詳述する。


3. メール転送実施モードの仕様 [AC579L84]

(1) コマンドライン: 「forward --config <設定ファイル>」 とする。

(2) 「設定ファイル」は、ユーザーがテキストエディタで記述した TOML ファイルであり、これを読み取り専用でロードする。設定ファイルは、[A44FBNFX] のような書式をしている。

--- [A44FBNFX] ここから ---

## 全体設定
[generic]

# [必須] アーカイブディリクトリ (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
archive_dir = "data/archive/"

# [必須] ログディレクトリ (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
log_dir = "data/log/"


## 転送フィルタ設定
[filter]

# [任意] 転送フィルタをユーザーが実装する C# ソースコードのファイル名 (相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる)
filter_csharp_filename = "secret_filter.cs"


## メールの転送元 (POP3 受信側メールボックス) の認証設定
[pop3]

# [必須] POP3 サーバーホスト名または IP アドレス
hostname = "pop3.example.org"

# [必須] POP3 サーバーの TCP ポート番号
port = 995

# [必須] SSL 使用モード (none = 未使用, starttls = 使用し、かつ START TLS モード, full = 使用し、かつ TCP 接続時から SSL でラップ)
ssl_mode = "full"

# [必須] SSL を使用する場合でかつサーバー側証明書を検証するか
ssl_verify_server_cert = true

# [任意] SSL を仕様する場合でかつサーバー側証明書を検証する場合において、サーバーが提示した証明書の「SHA1 ハッシュ」、「SHA192 ハッシュ」、「SHA256 ハッシュ」、「SHA384 ハッシュ」、「SHA512 ハッシュ」のいずれかの値が、以下の設定項目に記載された ASCII で 16 進数 (大文字 / 小文字は区別しない、空白が入っていても無視) のうちいずれか (";" または "," 文字で区切ると複数個指定できて、いずれか 1 個と一致していれば良い) と一致していれば、そのサーバー証明書は信頼してよい (この場合、Common Name やサーバー FQDN との不一致も許容される。また、有効期限が切れた証明書であっても良い)。この設定値。
ssl_trusted_static_hash_list = "e3a9f4c27b1d8e6a90c5f12b7a4d3e8c9f0a6b2d;9f3c1a7e4b6d0c8a2e5f91b4d7a6c0e3f8b2d1a9c5e4f6b0d3a7e2c9"

# [必須] POP3 ユーザー認証のためのユーザー名
username = "aaa"

# [必須] POP3 ユーザー認証のためのパスワード
password = "bbb"

# [必須] TCP 接続リトライ回数
tcp_retry_attempts = 3

# [必須] TCP 接続タイムアウト秒数
tcp_connect_timeout_secs = 6

# [必須] TCP 通信の送信タイムアウト秒数
tcp_send_timeout_secs = 60

# [必須] TCP 通信の受信タイムアウト秒数
tcp_recv_timeout_secs = 60

# [必須] 1 回の POP3 ログインごとに回す最大メール数
max_batch_mails_per_login = 10


## メールの転送先 (Gmail API) の認証設定
[gmail]

# [必須] 「Gmail OAuth トークン取得モード」 (gettoken モード) [F3QBRBA9] で作成された Gmail 用トークンファイルを指定する。相対パスを指定した場合は、この TOML 設定ファイルが存在するディレクトリからの相対パスとなる。
token_json = "secret_token.json"

# [必須] Gmail API の HTTPS (SSL) においてサーバー側証明書を検証するか
ssl_verify_server_cert = true

# [必須] TCP 接続リトライ回数
tcp_retry_attempts = 3

# [必須] TCP 接続タイムアウト秒数
tcp_connect_timeout_secs = 6

# [必須] TCP 通信の送信タイムアウト秒数
tcp_send_timeout_secs = 60

# [必須] TCP 通信の受信タイムアウト秒数
tcp_recv_timeout_secs = 60

# [必須] トークンの更新間隔秒数
gmail_token_refresh_interval_secs = 15

# [必須] 最大メールバイト数
gmail_max_mail_size = 40000000

# [必須] システムメッセージの仮想メールアドレス
gmail_system_message_mail_address = "nobody <nobody@example.org>"


--- [A44FBNFX] ここまで ---

(3) メール転送実施モードが起動すると、まず、指定された TOML 設定ファイル [A44FBNFX] を読み込みパースする。スキーマと意味は [A44FBNFX] のコメント欄を参照すること。[必須] と記載されたフィールドは必須であり、空白またはおかしな値が入っていれば、例外を発生させる。

以下、致命的なエラーまたは警告的なエラーが発生したら、必ず、Error ログとして出力する。ログ内容メッセージは、英語とする。

(4) 次に、POP3 サーバーに接続し、ログインをする。なお、POP3 プロトコルは、.NET の BCL の TCP ライブラリおよび SSL ライブラリを用いて対話すること。POP3 プロトコルについて、外部の NuGet ライブラリを利用してはならない。POP3 プロトコルに係る TCP, SSL, タイムアウト等の制御パラメータは、[A44FBNFX] の各値を用いること。意味は、コメント欄を参照すること。

ログイン試行時およびログイン結果 (成功)、メールが何件あるか等の詳しい情報を、Info ログとして出力する。ログ内容メッセージは、英語とする。ただし、POP3 のユーザー名はログに記載するが、パスワードは、決して記載しない。

(4-1) ログインしたら、POP3 プロトコルを用いて、メールボックスに届いているメールを、1 件ずつ取得する。「(a) 1 件取得 → (b) アーカイブへの保存 → (c) Gmail への転送 → (d) その 1 件を削除」の順で繰り返す。ある (a) を開始したとき、(b) 、(c) を実施完了しない限り、絶対に、(d) は実施しないこと。これにより、仮に (b) または (c) への書き込みに失敗した場合にメールが失われるリスクを避けることができる。
 より詳細な手順は、次のとおりである。
 
 (a) 1 件取得
  POP3 プロトコルを用いて、メールを、1 件取得する。この時点では、メールはメールボックスから削除しない。
  ただし、すでに現在ログインしているセッションにおいて取得したメール数が max_batch_mails_per_login 件を超える場合は、いったん POP3 のレイヤでログアウトする。その後、再度、(4) に戻り、再度新たに POP3 にログインする。以降、POP3 の残りメールが全部なくなるまで、これを繰り返す。
  
  メールを取得したら、何件中何件目であるかと、取得したメールサイズを、Info ログとして出力する。ログ内容メッセージは、英語とする。
  
  [WZZM4P46] メール取得上の注意。POP3 プロトコルにおいては、最初のログイン後、(a)「STAT」によりメールの件数を取得し、次に、(b) LIST によりメールの一覧を取得する。(b) では、メール ID (そのセッション内でユニークな番号 [KHQN6UTY]) とメールサイズが列挙される。それ以降、RETR や DELE コマンドでは、[KHQN6UTY] を用いてメールを識別し、取得および削除する。この POP3 の手順を遵守すること。AI が最初に作成した「RunForwardInternalAsync」関数は、手抜きであり、「// ★ 1 セッション内では、常に 1 番目のメッセージを処理し続ける (削除したものは QUIT で反映され、再ログイン後も継続可能)」とあるが、これは 2 通以上のメールがメールボックスに入っているとはにうまくいかない。「[Error] APPERROR: POP3 error response: -ERR Message is deleted.」というエラーを発生させてしまう。十分注意し、POP3 プロトコルのコンベンションに併せるようにせよ。
 
 (a-2) メールを取得したら、メモリ内において、そのメールの内容をパースして ([Q9MZU6D5] 参照)、MailMetaData にメモリ上で格納する。電子メールのパースにおいて、一部パース困難な部分があっても、致命的例外を発生させずに、その困難な部分以外のパースをすること。ただし、完全にパースに失敗した場合は (そうなることはほとんど考えられないが)、MailMetaData の MailSize は単にメールサイズをバイト単位で格納し、PlainTextBody にはメールの本文をそのまま UTF-8 形式で無理矢理デコードした形式を入れること。

  パース結果の MailMetaData のうち、MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId の項目を、人間にわかりやすく、「POP3 サーバーから取得したメールの内容」として、Info ログとして出力する。

 
 (b) (a-2) で取得したメールを、アーカイブに保存する。アーカイブは、設定の「archive_dir」ディレクトリ内を作成し、さらに「YYMMDD」というサブディレクトリを作成し、その中に「YYMMDD_HHMMSS_SHA1_FROM64.txt」というファイル名で保存する (すでに txt が存在する場合は、上書きをする)。
   - YYMMDD と HHMMSS は、MailMetaData の DateTime_Received を、プログラムを実行しているコンピュータのローカル時刻にした日時 (日付 6 桁、時刻 6 桁) である。DateTime_Received が不明の場合は、「(a) で取得をした時点の日付 + 午前 00:00:00 の時刻」とすること。DateTime_Header は信頼できないので、参照しない。[CQVFZY4W]
   - SHA1 の部分は、「MailMetaData」を変数として、JSON に変換した結果を UTF-8 エンコードし、これを SHA1 でハッシュ化したものを、小文字 16 進数表記した値とする。たとえば、「2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c」のような値である。メールによって異なるが、複数回同じメールを POP3 サーバーから取得しても、同じ値になるはずである。
   - FROM64 の部分は、MailMetaData の AddressList_From におけるメールアドレス部分 (aaa@example.org のような部分) をそのまま記載する。ただし、「a-z」「A-Z」「0-9」「@」「+」「-」「_」「.」以外の文字は、すべて、安全のため、「_」に置換すること。また、文字数が 64 文字を超える場合は、先頭 64 文字のみにすること。
   - txt ファイルの内容は、次のようなバイナリファイルとすること。
     -- 先頭に、UTF-8 の BOM を付ける。
     -- ファイルの先頭部分には、まず、2 行改行を開けてから、MailMetaData をそのままシリアライズ化した結果の JSON データがバイナリとして貼り付けられる (その内部表現形式は JSON であるので UTF-8 である)。
     -- 次に、JSON データの次に 2 行改行を開けて、「===================================================================」 [U2LFKTKR] という文字列を貼り付け、改行する。
     -- 最後に、元の (a) で取得したこのメールの内容バイナリを、一切変更せず、そのまま書き出す。
   - つまり、1 個の txt ファイルに、メールを MailMetaData にパースした結果 (メタデータ的なもの) と、メールのデコード前のデータ (生データ) とが、[U2LFKTKR] という区切り文字列を境界として、共存している状態の内容とする。
   
  Info ログとして、アーカイブ保存した txt ファイルの出力先ファイル名とファイルサイズをわかりやすく出力する。

 (c) Gmail への転送処理は、次のように行なわれる。ただし、メールサイズが "gmail_max_mail_size" を超えている場合は、その旨を詳しく Error ログに記載して (書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId を、わかりやすく、併記する) 、Gmail への転送をスキップする。
 
   [A] Gmail に HTTPS API で接続する際の、HTTPS プロトコルに係る TCP, SSL, タイムアウト等の制御パラメータは、[A44FBNFX] の各値を用いること。意味は、コメント欄を参照すること。
    Gmail との通信は、.NET の BCL の TCP ライブラリおよび SSL ライブラリを用いて対話すること。Gmail API プロトコルについて、外部の NuGet ライブラリを利用してはならない。
   
   [B] Gmail API を呼び出すためのクレデンシャルは、[F3QBRBA9] で作成された、[A44FBNFX] 内の 「token_json」に指定されている JSON ファイルを使用すること。この JSON ファイルをまず読み取りで読む。LastRefreshDt よりも gmail_token_refresh_interval_secs 秒以上経過していたら、トークンの更新処理行なう。トークンの更新処理で新しいトークンが得られたら、「token_json」に指定されている JSON ファイルにそのトークンを書き込むこと。
   
   [C] Gmail API では、「users.messages.import」 API を用いて、この 1 件のメールのデータ ((a) で取得したものそのまま) を、「INBOX」「UNREAD」というラベルを確実に付けた上で、ユーザーの Gmail 受信トレイに書き込む。[T3C34TDJ]
      - インポート時は、neverMarkSpam=True オプションを有効にすること。[N9YQARM8]

  Info ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、これが Gmail メールボックスに書き込み完了した旨を、わかりやすく、出力する。
   
   [D] [C] の書き込みがエラーなく完了したことをもって、(d) へ行く。なお、何らかのエラーが発生した場合は、例外を発生させ、この時点でプログラムを終了させる。
   ただし、Gmail に 1 件のメールをアップロードしようとして、「400 Bad Request」が応答された場合、必要に応じた添付ファイルの削除処理 [GTFE562C] を行ない、それでもなおエラーになる場合のみ、例外を発生させ、この時点でプログラムを終了させる。[ULP8TK5N]

 (d) 最後に、POP3 サーバーから、対象メールを削除する処理を行なう。
  Info ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、これを POP3 サーバーから削除した旨を、わかりやすく、出力する。


81. ログ記録機能
(1) このプログラムの仕様で、「Error ログ」または「Info ログ」を出力するよう指示があった場合は、次のとおりログ出力をしなければならない。

(2) ログは、1 ログ 1 行のデータであり、[Y5CRNZA3] の書式を有する。
--- [Y5CRNZA3] ここから ---
YYYY/MM/DD HH:MM:SS.SSS +XX:XX [Type] 本文
--- [Y5CRNZA3] ここまで ---

「YYYY/MM/DD HH:MM:SS.SSS +XX:XX」は、ログを出力しようとする瞬間の日時 (ミリ秒単位) である。タイムゾーンを併記し、タイムゾーンはシステムのローカル時計設定にあわせる。

Type には、Error または Info のいずれかが入る。

本文は、1 行の何らかの 0 文字以上の文字列である。ログ書き込みをしようとする側が、改行を含んでいた場合は、改行 ("\r\n" または "\n") は、" / " という文字に置換され、必ず 1 行となる。

(3) ログは、設定ファイル [A44FBNFX] の「log_dir」ディレクトリ内に、「YYMMDD.log」というファイル名で保存 (追記型書き込み) される。

(4) ログを保存しようとする際には、それと全く同一の行を、Error の場合は標準エラー出力、Info の場合は標準出力に文字列として出力する。

(5) ログの保存またはディレクトリの作成に失敗した場合の例外は、その旨を標準エラー出力に出した上で、続行する (例外を無視する)。


91. Gmail との OAuth トークン情報 JSON ファイルの書式 [EG8R7RTE]
--- ここから ---
public class GMailOAuthTokenJsonData
{
    public DateTimeOffset LastRefreshDt; // 最後に更新された日時
    public string AppClientId; // クライアントアプリ ID
    public string AppClientSecret; // クライアントシークレット
    public string UserAccessToken; // アクセストークン (必要に応じて更新される)
}
--- ここまで ---


92. メール本文の内部データ [VZR2Y5BY]
--- ここから ---
public class MailMetaData
{
    public int MailSize;   // メールのサイズ (単位: バイト)
    
    public string Subject; // Subject の文字列。デコード済み。無い場合は ""。
    
    public DateTimeOffset? DateTime_Header; // Date ヘッダの日時。不明な場合は null。注意: [YU4CRZ2B] を参照。
    
    public DateTimeOffset? DateTime_Received; // Received ヘッダから推定されるメールの配信日時。不明な場合は null。注意: [KDXFFA9U] を参照。
    
    public string MessageId; // メッセージ ID 文字列。無い場合は ""。
    
    public System.Net.Mail.MailAddress? AddressList_From; // From メールアドレス。不明な場合は null。
    public List<System.Net.Mail.MailAddress> AddressList_To; // To メールアドレス一覧。存在しない場合は空のリスト。
    public List<System.Net.Mail.MailAddress> AddressList_Cc; // Cc メールアドレス一覧。存在しない場合は空のリスト。
    public List<System.Net.Mail.MailAddress> AddressList_ReplyTo; // ReplyTo メールアドレス一覧。存在しない場合は空のリスト。
    public List<string> AddressList_ReturnPath; // Return-Path アドレス一覧。存在しない場合は空のリスト。注意: "<username@example.org>" あるいは "aaa bbb <username@example.org>" の形式で元メールに入っている場合、メールアドレス部分、すなわち "<>" を除外した "username@example.org" の部分のみを格納せよ。なお、"<>" となっている場合は、その部分は、空文字 "" を格納せよ。なお、"username@example.org" の部分のみ元メールに入っている場合は、それをそのまま利用せよ。 [SS9R4XHX]
    public List<string> AddressList_OriginalTo; // X-Original-To アドレス一覧。存在しない場合は空のリスト。[SS9R4XHX] の注意書きに同じ。
    public List<string> AddressList_DeliveredTo; // Delivered-To アドレス一覧。存在しない場合は空のリスト。[SS9R4XHX] の注意書きに同じ。
    
    public string PlainTextBody; // 平文メールとして処理したときの平文メール本文全文 (デコード済み)。平文部分が存在しない場合は ""。
    public string HtmlBody; // HTML メールとして処理したときの HTML メール本文全文 (デコード済み)。HTML メールではない場合は ""。
    public string HtmlBodyToPlainText; // HtmlBody には、HTML タグが詰まっていて、「&nbsp;」や HTML のいろいろなエンコード方式でのエスケープがなされている可能性がある。これを、あとで全文検索エンジンに投入可能な程度に、普通の平文文字列に置換した状態 (つまり、ユーザーがテキストビューアでそのメールを表示しようとすると表示されるべき状態) の文字列を格納する。HTML メールではない場合は ""。
    
    public List<string> AttachmentFileNamesList; // 添付ファイル名のリスト。存在しない場合は空のリスト。なお、HTML メールの場合、HTML 本文や HTML 本文内の画像などが含まれている場合があるが、これらは添付ファイルとしてはここに入れないこと。普通のメーラにおいて、「添付ファイル」であるとみなされるものが、添付ファイルである。
}
--- ここまで ---

92-2. Received ヘッダから日時を取得する際の注意 [KDXFFA9U]
(1) メールの Received ヘッダの表記方法には、歴史的経緯から、色々な揺れがある可能性がある。その揺れについて詳しくリサーチし、それを解消して、確実に日時が取得できる方法によるパーサーを作成すること。
(2) 一例として、[C993C7RT] のようなメールがみられる。[C993C7RT] のようなものは、確実にパースできるようにすること。他にも色々トラブル原因あると思うので、インターネットで色々な方言について調査研究し、良いパーサーを書くこと。

--- [C993C7RT] ここから ---
Received: from mail-qv1-f48.google.com (mail-qv1-f48.google.com [209.85.219.48])
	by example.org (Postfix) with ESMTPS id 5D64D1292BDF
	for <example.org@example.org>; Thu, 18 Dec 2025 20:45:02 +0900 (JST)
Received: by mail-qv1-f48.google.com with SMTP id aaaa-bbbba.0
        for <example.org@example.org>; Thu, 18 Dec 2025 03:45:02 -0800 (PST)
--- [C993C7RT] ここまで ---


92-3. Date ヘッダから日時を取得する際の注意 [YU4CRZ2B]
(1) メールの Date ヘッダの表記方法には、歴史的経緯から、色々な揺れがある可能性がある。その揺れについて詳しくリサーチし、それを解消して、確実に日時が取得できる方法によるパーサーを作成すること。
(2) (1) のパーサーについて、「MimeKit」のライブラリにその揺れの吸収が可能な機能があり、かつ、それが信頼できる場合は、それを利用すること。


93. Gmail メールをアップロードしようとして、「400 Bad Request」が応答された場合の、必要に応じた添付ファイルの削除処理 [GTFE562C]
(1) Gmail にウイルス等の疑いがあるメール (添付ファイル付きメール、本文にマルウェアの URL が記載されているメール等) をアップロードしようとすると、「400 Bad Request」というエラーが Gmail API から応答されることがある。
(2) この場合、以下の (a), (b), (c) のメールを内部的にメモリ上で作成し、順に、インポートを再試行する。(a), (b), (c) の順で、1 つでもインポートが成功すれば、残りは不要である。
   (a) メールから、[LA5UBK7L] の拡張子を有するファイル名 (あるいはこれらのファイル名に .gz または .bz2 が付いたファイル名) のすべての添付ファイルを削除したもの。この処理は MimeKit で可能である。
   (b) メールに .zip, .tar.gz, .tgz, .tar のアーカイブファイルが付いている場合は、その内容を走査して (ファイルの内容そのものは読まず、ファイル名だけ読めば良い)、それらの中に、[LA5UBK7L] の拡張子を有するファイル名 (あるいはこれらのファイル名に .gz または .bz2 が付いたファイル名) がある場合は、その添付ファイルたるアーカイブファイルを削除したもの。この処理は MimeKit で可能である。
   (c) メールからすべての添付ファイルを削除したもの。この処理は MimeKit で可能である。
   なお、(a), (b), (c) において、メールの「Subject」文字列には、「【注: 転送時に添付ファイル削除】 ○○」という文字列を前置すること (○○ は元の Subject 文字列)。元の Subject 文字列がない場合、「○○」の部分は空文字にすること。
(3) (2) で、すべてのインポートで、「400 Bad Request」が応答された場合は、代わりに「システムメッセージ」 ([HA7DHHGE]) を作成し、これをメールボックスにインポートする。システムメッセージの [件名] は、[L58QWMGX] とし、 <> の部分は指示に従って埋める。本文は、[G35AJFPZ] とし、<> の部分は指示に従って埋める。
(4) システムメッセージのインポートに成功した場合、Error ログとして、書き込み対象メールの MailSize、DateTime_Received、AddressList_From、AddressList_To、Subject、MessageId と、"Gmail サーバーへのインポートに失敗した" 旨を、わかりやすく、出力する。
(5) (2) または (3) でインポートに成功したら、そのメールの Gmail へのインポートは成功したとみなす。それ以外の場合は、エラーとみなす。

--- [LA5UBK7L] ここから ---
.ade, .adp, .apk, .appx, .appxbundle, .bat, .cab, .chm, .cmd, .com, .cpl, .diagcab, .diagcfg, .diagpkg, .dll, .dmg, .ex, .ex_, .exe, .hta, .img, .ins, .iso, .isp, .jar, .jnlp, .js, .jse, .lib, .lnk, .mde, .mjs, .msc, .msi, .msix, .msixbundle, .msp, .mst, .nsh, .pif, .ps1, .scr, .sct, .shb, .sys, .vb, .vbe, .vbs, .vhd, .vxd, .wsc, .wsf, .wsh, .xll,
--- [LA5UBK7L] ここまで ---

--- [L58QWMGX] ここから ---
【メール転送インポート失敗】: Subject: <○○○> (From: <AddressList_From>)
--- [L58QWMGX] ここまで ---

--- [G35AJFPZ] ここから ---
以下のメールを Gmail API を用いて転送インポートしようとしたところ、
エラーメッセージ「ERROR」が発生しました。

メールのサイズ: <XXX> バイト
メールの Subject: <○○○>
メールの日時: <DateTime_Header を文字列化したもの>
メールの From: <AddressList_From を文字列化したもの>
メールの To: <AddressList_To (複数あるときは ", " で結合) を文字列化したもの>
メールの Cc: <AddressList_Cc (複数あるときは ", " で結合) を文字列化したもの>
メールの添付ファイルの数: <○> 個
--- [G35AJFPZ] ここまで ---


93-2. Gmail へのシステムメッセージのアップロード [HA7DHHGE]
(1) システムメッセージのメールは、次のとおりとする。
- From, To はいずれも [A44FBNFX] の gmail_system_message_mail_address の文字列とする。
- ReturnPath は gmail_system_message_mail_address の文字列のうちメールアドレス部分 ( "<username@example.org>" あるいは "aaa bbb <username@example.org>" の形式で元メールに入っている場合、メールアドレス部分、すなわち "<>" を除外した "username@example.org" の部分のみを格納せよ。) とする。
- MessageId は RFC に準拠し乱数で絶対重複しない ID 文字列を生成して格納すること。
- Subject は「sysmsg [件名]」とする。
- Body はテキスト文字列とする。
- エンコーディングは UTF-8 とする。
- Date は、そのメッセージを作成した日時とする。
(2) (1) で作成したシステムメッセージは、[T3C34TDJ] と同等の方法でインポートすること。これにより、ユーザーは、メールボックスを通じて、そのメールを確認できる。
(3) (2) のインポート時に、万一システムメッセージのインポートでエラーが発生したら、その旨は Error ログとして記録するが、例外はキャッチし、無視して続行する。



99. 使用ライブラリ (Nuget) [Q9MZU6D5]
- TOML 設定ファイルの読み書きが必要な場合には、「Tomlyn」ライブラリを使用すること。
- POP3 等において、電子メールデータのパースには、「MimeKit」ライブラリを使用すること。




